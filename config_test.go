package genenv

import (
	"os"
	"path/filepath"
)

// resets g Target and Package
func (suite *GenenvTestSuite) resetTP(cfg *Config) {
	cfg.Target = ""
	cfg.Package = ""
}

func (suite *GenenvTestSuite) TestConfigInit() {
	d, err := os.MkdirTemp(suite.d, "*")
	suite.Require().NoError(err)
	defer os.RemoveAll(d)

	cfg := &Config{}
	suite.ErrorIs(cfg.init(), ErrNoVar)

	// Cover module loading and mock it + header default.
	cfg.Variables = map[string]Spec{"foo": {}}
	cfg.Package = "okpkg"
	cfg.Target = filepath.Join("testdata", "target", "ok")
	suite.Zero(cfg.Header)
	suite.NoError(cfg.init())
	suite.Equal("// Code generated by genenv. DO NOT EDIT.", cfg.Header)
	cfg.mod = &ModInfo{
		Path: "github.com/marcozac/fakemod",
		Dir:  d,
	}

	// No Package or Target.
	suite.resetTP(cfg)
	target := filepath.Join(cfg.mod.Dir, "internal", "env")
	suite.NoDirExists(target)
	suite.NoError(cfg.init())
	suite.DirExists(target)
	suite.Equal(target, cfg.Target)
	suite.Equal("env", cfg.Package)

	// No Target => assigned from package name.
	suite.resetTP(cfg)
	cfg.Package = "foo"
	target = filepath.Join(filepath.Dir(target), "foo")
	suite.NoDirExists(target)
	suite.NoError(cfg.init())
	suite.DirExists(target)
	suite.Equal(target, cfg.Target)
	suite.Equal("foo", cfg.Package)

	// No Package => assigned from target base.
	cfg.Package = ""
	suite.NoError(cfg.init())
	suite.Equal(target, cfg.Target)
	suite.Equal("foo", cfg.Package)

	// Aliasing error.
	//
	// cfg.Package: foo
	// cfg.Target: <temp>/internal/foo
	// package in *.go: bar
	var f *os.File
	f, err = os.CreateTemp(target, "*.go")
	suite.Require().NoError(err)
	_, err = f.WriteString("package bar\n")
	f.Close()
	suite.Require().NoError(err)
	suite.ErrorContains(cfg.init(), "inconsistent package name")

	// Aliasing ok.
	// Same target above.
	// cfg.Target: <temp>/internal/foo
	cfg.Package = "bar"
	suite.NoError(cfg.init())
	suite.Equal(target, cfg.Target)
	suite.Equal("bar", cfg.Package)

	// No Package => assigned from target (aliased).
	// Same target above.
	// cfg.Target: <temp>/internal/foo
	cfg.Package = ""
	suite.NoError(cfg.init())
	suite.Equal("bar", cfg.Package)

	// Mkdir Target (aliased).
	cfg.Package = "hello"
	cfg.Target = filepath.Join(d, "world")
	suite.NoDirExists(cfg.Target)
	suite.NoError(cfg.init())
	suite.DirExists(cfg.Target)
	suite.Equal("hello", cfg.Package)

	// Target package error.
	cfg.Package = "x"
	cfg.Target = filepath.Join(suite.modInfo.Dir, "testdata", "target", "err")
	suite.Error(cfg.init())
	suite.resetTP(cfg)

	// ModInfo error.
	// Out of module directory.
	wd, err := os.Getwd()
	suite.Require().NoError(err)
	suite.Require().NoError(os.Chdir(suite.T().TempDir())) // change wd
	defer func() {
		suite.Require().NoError(os.Chdir(wd))
	}()
	suite.ErrorContains((&Config{Variables: map[string]Spec{"foo": {}}}).init(), "out of module directory")
}

func (suite *GenenvTestSuite) TestReadConfig() {
	g, err := ReadConfig(suite.f)
	suite.NoError(err)

	suite.Require().NotNil(g)
	suite.Require().NotNil(g.Variables)

	suite.Require().Contains(g.Variables, "FOO")
	suite.Require().Contains(g.Variables, "BAR")

	suite.Contains(g.Variables["FOO"].Allow, "foo")
	suite.Contains(g.Variables["BAR"].Deny, "bar")

	// Open error.
	p := filepath.Join(suite.d, "readconfigfake")
	suite.NoFileExists(p)
	_, err = ReadConfig(p)
	suite.Error(err)

	// Decode error.
	var f *os.File
	f, err = os.CreateTemp(suite.d, "*")
	suite.NoError(err)
	_, err = ReadConfig(f.Name())
	suite.Error(err)
}
